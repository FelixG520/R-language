#一、正整数向量索引
x <- c(1:100)
lenth(x)#计算x中的元素个数
x[1]#访问向量第一个值，用[]
x[0]#什么也不会输出，向量的索引从1开始，与其他编程语言有所不同
x[-19]#表示除了第19个元素之外全部输出
x[c(4:18)]#输出第4到18个元素
x[c(1,23,45,67,89)]#输出第1,23,45,67,89个元素
x[c(11,11,23,23,5,90,2)]#同一个元素可以输出多次
x[c(-2,3,4)]#只有0可以与负下标混合

y <- c(1:10)
y[c(T,F,T,T,F,F,T,T,T,F)]#只输出逻辑值为真的元素
y[c(T)]#逻辑值的数量可以不与元素的数量相同——只有一个T默认全为真
y[c(F)]#只有一个F默认全假，都不输出
y[c(T,F)]#按真假的顺序依次输出——只输出奇数
y[c(T,F,F)]#同理俺真假假的顺序输出
y[c(T,F,T,T,F,F,T,T,T,F,T)]#逻辑值的数量大于元素数量时产生缺失值——NA
y[y>5]#只输出大于5的元素
y[y>5 && y<9]#输出大于5小于9的数

#二、字符串向量索引
# 包含运算符 %in%——表示判断左是否在右
z <- c("one","two","three","four","five")

"one" %in% z#"one"是否在z中——TRUE
z["one" %in% z]#将TRUE的元素输出——相当于z[T]即z[T,T,T,T,T]

z %in% c("one","two")#z中哪几个元素是"one","two"，然后把z中这几个元素的逻辑值输出——T T F F F
z[z %in% c("one","two")]#z[z %in% c("one","two")]相当于z[T,T,F,F,F]

k <- z %in% c("one","two")#k=[c(T,T,F,F,F)]
z[k]#将z中元素按T,T,F,F,F的顺序输出

#三、名称索引
names(y) <- c("one","two","three","four","five","six","seven","eight","nine","ten")
names(y)#names()函数对y中的每个元素起名
y["one"]#可以通过元素名输出对应值——用[]

#四、修改向量——添加、删除、修改
x <- c(1:100)
x[101] <- 101#直接通过索引来添加向量——将下标为101的元素改为101
v <- 1:3
v[c(4,5,6)] <- c(4,5,6)#一次性添加多个元素——在下标4，5，6的位置加上4，5，6
v[20] <- 4#在下标20的位置加上4，其余位置补NA
append(x=v,values=99,after=5)#append()函数插入数据，在v中下标为5的元素后加99
append(v,99,0)#在向量开头加上99,(x=,values=,after=)可省略

#rm(v)#将v向量删除
y[-c(1:3)]#删除y前三个元素
y <- y[-c(1:3)]#删除y前三个元素，并重新赋值给y——其实就是重新生成一个新的向量，替换掉原来的向量
y["four"] <- 100#将名称为four的元素修改为100
v[2] <- 15#将v下表为2的元素改为15
v[2] <- "one"#若赋值字符串，会把整个向量变成字符型向量
























































